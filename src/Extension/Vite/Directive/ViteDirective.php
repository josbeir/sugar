<?php
declare(strict_types=1);

namespace Sugar\Extension\Vite\Directive;

use Sugar\Core\Ast\ElementNode;
use Sugar\Core\Ast\Helper\ExpressionValidator;
use Sugar\Core\Ast\Helper\NodeCloner;
use Sugar\Core\Ast\Node;
use Sugar\Core\Ast\OutputNode;
use Sugar\Core\Compiler\CompilationContext;
use Sugar\Core\Directive\Enum\DirectiveType;
use Sugar\Core\Directive\Interface\ContentWrappingDirectiveInterface;
use Sugar\Core\Directive\Interface\DirectiveInterface;
use Sugar\Core\Directive\Interface\ElementClaimingDirectiveInterface;
use Sugar\Core\Escape\Enum\OutputContext;
use Sugar\Core\Runtime\RuntimeEnvironment;
use Sugar\Extension\Vite\Runtime\ViteAssetResolver;

/**
 * Compiler for `s:vite` content directive.
 *
 * Emits HTML tags generated by ViteAssetResolver at runtime.
 */
final class ViteDirective implements
    DirectiveInterface,
    ContentWrappingDirectiveInterface,
    ElementClaimingDirectiveInterface
{
    /**
     * @param \Sugar\Core\Ast\DirectiveNode $node
     * @return array<\Sugar\Core\Ast\Node>
     */
    public function compile(Node $node, CompilationContext $context): array
    {
        $expression = ExpressionValidator::normalizeRuntimeExpression(
            expression: $node->expression,
            emptyFallback: 'true',
            bareStringPattern: '/^[a-zA-Z0-9_@.\/-]+$/',
        );

        $runtimeCall = RuntimeEnvironment::class
            . '::requireService(' . ViteAssetResolver::class . '::class)'
            . '->render(' . $expression . ')';

        $outputNode = new OutputNode(
            expression: $runtimeCall,
            escape: false,
            context: OutputContext::RAW,
            line: $node->line,
            column: $node->column,
        );
        $outputNode->inheritTemplatePathFrom($node);

        if ($node->children === []) {
            return [$outputNode];
        }

        $firstChild = $node->children[0];
        if ($firstChild instanceof ElementNode) {
            $modifiedElement = NodeCloner::withChildren($firstChild, [$outputNode]);

            return [$modifiedElement];
        }

        return [$outputNode, ...$node->children];
    }

    /**
     * @inheritDoc
     */
    public function getType(): DirectiveType
    {
        return DirectiveType::OUTPUT;
    }

    /**
     * @inheritDoc
     */
    public function shouldWrapContentElement(): bool
    {
        return false;
    }

    /**
     * @inheritDoc
     */
    public function getElementExpressionAttribute(): string
    {
        return 'src';
    }
}
